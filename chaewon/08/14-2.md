# 섹션 14. 가상 메모리

## 연속 메모리 할당

- 프로세스에 연속적인 메모리 공간을 할당

![연속 메모리 할당](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2014%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%203ab48120de9d4116a7151943a1d6e7e2/image.png)

연속 메모리 할당

## 스와핑

메모리 관리 기능1

- 현재 사용되지 않는 프로세스들을 보조기억장치의 일부 영역으로 쫓아내고(**스왑 아웃**), 그렇게 생긴 빈 공간에 새 프로세스 적재(**스왑 인**)
- 프로세스들이 요구하는 메모리 공간 크기 > 실제 메모리 크기 인 경우에도 적절한 스와핑으로 정상 실행 가능
- free, top 등의 명령어로 스왑 영역 크기 확인 가능

### 메모리 할당

- 프로세스는 메모리의 빈 공간에 할당되어야 함
- 만약 빈 공간이 여러 개 존재한다면?
    - **최초 적합(first-fit)**
        - 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다 적재 가능 공간 발견 시 배치
        - 검색 최소화, 빠른 할당
    - **최적 적합(best-fit)**
        - 운영체제가 빈 공간을 모두 검색 후, 적재 가능한 공간 중 가장 작은 공간에 적재
    - **최악 적합(worst-fit)**
        - 운영체제가 빈 공간을 모두 검색 후, 적재 가능한 공간 중 가장  공간에 적재

### 외부 단편화

- 위처럼 연속적으로 메모리에 할당하는 방식은 비효율적
    
    ⇒외부 단편화 문제
    
- 프로세스를 할당하기 어려울 만큼 작은 메모리 공간들로 인해 메모리가 낭비되는 현상

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2014%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%203ab48120de9d4116a7151943a1d6e7e2/image%201.png)

### 외부 단편화의 해결

1. **메모리 압축**
    - 여기저기 흩어진 빈 공간들을 하나로 모으는 방식
    - 프로세스들을 적당히 재배치해 흩어진 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법
    - 재배치와 합치는 과정에서 오버헤드 문제 가능성
2. **페이징**
    - 현대 운영체제가 대중적으로 선택하는 외부 단편화 해결 방식

## 페이징을 통한 가상 메모리 관리

### 가상 메모리

- 실행하고자 하는 프로그램을 일부만 적재해서 물리 메모리보다 훨씬 큰 프로그램을 실행 가능하게 하는 기술
- 관리 기법
    - **페이징**
    - 세그멘테이션

### 페이징

- 외부 단편화의 근본적 문제
    
    : **각기 다른 크기**의 프로세스가 메모리에 연속적으로 할당되었기 때문
    

⇒ 모든 프로세스를 일정 크기로 자르고, 이를 불연속적으로 할당하면 문제가 없다!

- 프로세스의 논리 주소 공간을 **페이지**라는 일정 단위로 자름
- 메모리의 물리 주소 공간을 **프레임**이라는 페이지와 동일한 일정 단위로 자름
- 페이지를 프레임에 할당

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2014%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%203ab48120de9d4116a7151943a1d6e7e2/image%202.png)

- **페이징에서의 스와핑**
    - 프로세스 단위의 스왑 인, 스왑 아웃이 아닌 페이지 단위의 스왑 인(페이지 인), 스왑 아웃(페이지 아웃)
    - 메모리에 적재될 필요가 없는 페이지들은 보조기억장치로 스왑 아웃
    - 실행에 필요한 페이지들만 스왑 인
    
    → 프로세스 실행을 위해 모든 페이지가 메모리에 적재될 필요가 없음
    
    → **물리 메모리보다 큰 프로세스도 실행 가능**
    

### 페이지 테이블

- 위에서 나온 페이징의 문제
    - 프로세스를 이루는 페이지가 불연속적으로 존재 가능
    
    ⇒ CPU가 프로세스의 페이지들이 어느 프레임에 적재되어 있는지 파악 어려움
    
    ⇒ CPU 입장에서 순차적 실행 불가
    
    ⇒ 다음에 실행할 명령어 위치 찾기 어려움
    
    ⇒ 페이지 테이블 등장
    
- 물리 주소에 불연속적으로 배치되어도 논리 주소(CPU 입장의 주소)에는 연속적으로 배치되도록 하는 방법
- **페이지 번호와 프레임 번호를 짝지어 주는 이정표**
- 프로세스마다 페이지 테이블 존재
- 물리적으로는 분산되어 저장되어 있어도 CPU 입장에서는 연속적으로 보임
- **CPU는 논리 주소를 순차적 실행**

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2014%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%203ab48120de9d4116a7151943a1d6e7e2/image%203.png)

![페이징 테이블](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2014%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%203ab48120de9d4116a7151943a1d6e7e2/image%204.png)

페이징 테이블

### 페이징의 문제

- **내부 단편화 문제** 야기 가능
    - 프로세스의 전체 크기가 페이징 단위 크기의 배수라는 보장이 없음
    - ex) 프로세스 크기 108kb, 페이지 크기 10kb… 2kb의 내부 단편화 발생
    - 하나의 페이지 크기보다 작은 크기로 발생 ⇒ 외부 단편화 크기보다 보통 작다!
    

<aside>
❗ **대형 페이지**도 존재(huge page)

</aside>

### PTBR

- 프로세스마다 페이지 테이블이 존재
- 각 페이지 테이블(메모리에 적재)의 위치는 CPU 내의 **프로세스 테이블 베이스 레지스터**(PTBR)이 가르킴
- 그런데, 페이지 테이블이 메모리에 있으면 **메모리 접근 시간이 두 배**로 증가
    - 페이지 테이블 참조용 1회 , 페이지 참조용 1회

### TLB

- CPU 곁에 페이지 테이블을 저장한 캐시 메모리
- 메모리에 적재된 페이지 테이블의 일부를 가져와 저장
- CPU가 접근하려는 논리 주소가 TLB에 존재한다면, **TLB 히트** (메모리 접근 1회)
- CPU가 접근하려는 논리 주소가 TLB에 존재하지 않는다면, **TLB 미스** (메모리 접근 2회)

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2014%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%203ab48120de9d4116a7151943a1d6e7e2/image%205.png)

### 페이징에서의 주소 변환

- 특정 주소에 접근하고자 한다면 필요한 정보는?
    - 어떤 페이지 혹은 프레임에 접근하고 싶은지
    - 접근하려는 주소가 그 페이지 혹은 프레임으로붙 얼마나 떨어져 있는지…
- 페이징 시스템에서의 논리 주소
    - **페이지 번호와 변위**(오프셋)

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2014%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%203ab48120de9d4116a7151943a1d6e7e2/image%206.png)

⇒ **<페이지 번호, 변위>** 로 이루어진 논리 주소는 페이지 테이블을 통해 **<프레임 번호, 변위>**로 변환 (페이지 크기 = 프레임 크기 이므로, 각 변위 값도 동일)

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2014%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%203ab48120de9d4116a7151943a1d6e7e2/image%207.png)

### 페이지 테이블 엔트리(PTE)

- 페이지 테이블의 각각의 행
- 페이지 번호와 프레임 번호 외에…
- **유효 비트**
    - 현재 해당 페이지에 접근 가능한지 여부
    - 현재 메모리에 적재(스왑 )되어 있는지 여부
    - 유효 비트가 0인 페이지에 접근 시,
        - **페이지 폴트라는 인터럽트** 발생
- **보호 비트**
    - 페이지의 보호 기능을 위해 존재하는 비트
    - 읽기 전용 페이지인지 등…
    - rwx 형태
- **참조 비트**
    - CPU가 이 페이지에 접근한 적 있는지 여부
- **수정 비트(dirty bit)**
    - CPU가 이 페이지에 데이터를 쓴 적 있는지 여부
    - 스와핑을 위해 존재하는 비트
        - 수정된 페이지는 스왑 아웃될 때 보조 기억장치에도 덮어쓰기 작업을 거쳐야 함

![image.png](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2014%20%E1%84%80%E1%85%A1%E1%84%89%E1%85%A1%E1%86%BC%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%203ab48120de9d4116a7151943a1d6e7e2/image%208.png)