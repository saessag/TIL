# 섹션 6. 메모리와 캐시 메모리

이번 섹션에서는 4가지 주요 부품 중, 메모리를 다룬다.

메모리

- **주기억장치**
    - **RAM**(=일반적으로 메모리라고 부를 때는 RAM을 지칭하는 경우가 多)
    - ROM
- 보조기억장치

RAM의 용량에 따른 정확한 차이, RAM의 다양한 종류를 배운다.

## RAM의 특징과 종류

CPU는 RAM으로부터 명령어와 데이터를 가져와 실행, **RAM**은 실행할 내용을 저장하지만 **휘발성**. 보조기억장치에 보관할 대상을 저장(비휘발성)

### RAM의 용량과 성능

> 통상적으로 RAM은 크면 클수록 좋다!
> 

![작은 RAM의 문제…(동시에 여러 프로그램 실행 시에 문제가 있다.)](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%206%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%8F%E1%85%A2%E1%84%89%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20450269d12b9146e3b6c066b7e0bded18/Untitled.png)

작은 RAM의 문제…(동시에 여러 프로그램 실행 시에 문제가 있다.)

즉, **RAM이 크다는 것은 동시에 많은 프로그램 실행 시에 유리**

### RAM의 종류

- **DRAM**(Dynamic RAM)
    - 동적 RAM
    - 저장된 데이터가 **동적으로 사라지는(컴퓨터 전원이 들어와있는데도 데이터가 점점 삭제…!)** RAM
    - 데이터 소멸을 막기 위해 **주기적 재활성화(=리프레시) 필요**
    - 계속 멋대로 데이터를 없애는 RAM을 굳이 사용할까?
        
        ⇒ 일반적으로 사용하는 RAM이 DRAM!
        
        ⇒ **상대적으로 낮은 소비전력, 저렴함, 높은 집적도(오밀조밀하게 설계 가능), 대용량 설계 용이**
        
- **SRAM**(Static RAM)
    - 정적 RAM
    - 저장된 데이터가 **사라지지 않는(물론 어디까지나 전원이 연결되어 있을 때)** RAM
    - DRAM보다 일반적으로 빠르다!
    - 일반적으로 **캐시 메모리**에 사용되는 RAM
        - **상대적으로 높은 소비전력, 높은 가격, 낮은 집적도**
        
        ⇒ **대용량 설계가 필요 없고, 아무튼 빠른 속도가 필요한 장치에 사용** 
        
    
    ![DRAM VS SRAM](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%206%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%8F%E1%85%A2%E1%84%89%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20450269d12b9146e3b6c066b7e0bded18/Untitled%201.png)
    
    DRAM VS SRAM
    
- **SDRAM(Synchronous DRAM)**
    - 특별한 DRAM
    - **클럭 신호와 동기화** 된 DRAM
        - 클럭 신호가 한 번 발생할 때 SDRAM도 같은 주기, 같은 박자로 데이터 하나를 주고 받을 수 있다.
- **DDR SDRAM(Double Data Rate SDRAM)**
    - 특별한 SDRAM
    - **현대에서 가장 대중적**으로 사용하는 RAM
    - **대역폭을 넓혀(=주고 받는 속도, 데이터 용량을 더 높인…) 속도를 높인** SDRAM
        - **대역폭은 데이터를 주고받는 길의 너비**(1차선 도로와 N차선 도로에 통행 가능한 차량의 수로 비유해 생각하자)
        - 위의 일반 SDRAM을 SDR(Single Data Rate) SDRAM이라고도 부른다.
        - 즉 DDR SDRAM은 대역폭이 두 배 넓은 SDRAM
- DDR2 SDRAM
    - DDR SDRAM 보다 대역폭을 2배 넓인 RAM
    - DDR3, DDR4 도 있다. 대역폭 차이가 동일하게 존재, 이외 정의는 마찬가지.
    - 요즘 자주 사용하는 것은 **DDR4**

## 메모리의 주소 공간

### 물리주소 VS 논리주소

메모리 내에 주소 체계는 두 가지가 존재한다.

**논리 주소**

- CPU와 실행 중인 프로그램의 입장에서 바라본 주소. 실제 주소는 아님.
- 실행 중인 프로그램 각각에게 부여된 0번지부터 시작하는 주

**물리 주소**

- 실제 하드웨어 내의 주소, 메모리 입장에서 바라보는 주소

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%206%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%8F%E1%85%A2%E1%84%89%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20450269d12b9146e3b6c066b7e0bded18/Untitled%202.png)

> CPU와 실행 중인 프로그램들은 현재 메모리 어디에 무엇이 저장되어 있는지 모두 알고 있을까?
> 

⇒ NO!

⇒ **메모리에 저장되는 값들은 계속 변한다!**

⇒ 새롭게 실행되는 프로그램은 메모리에 추가, 실행이 끝난 프로그램은 메모리에서 삭제, 동일 프로그램을 재시작해도 적재되는 주소는 그때그때 변경

### 물리 주소와 논리 주소의 변환

![주소 변환 과정의 필요성](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%206%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%8F%E1%85%A2%E1%84%89%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20450269d12b9146e3b6c066b7e0bded18/Untitled%203.png)

주소 변환 과정의 필요성

CPU와 메모리 사이에 존재하는 **MMU(메모리 관리 장치)**라는 하드웨어가 변환

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%206%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%8F%E1%85%A2%E1%84%89%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20450269d12b9146e3b6c066b7e0bded18/Untitled%204.png)

CPU가 이해하는 주소는 항상 논리 주소, CPU가 던진 논리 주소를 주소 버스를 통해 보내면 MMU가 물리 주소로 변환한다. 반대도 마찬가지로 물리주소에서 논리 주소로 변환해준다.

MMU는 **논리 주소와 베이스 레지스터(프로그램의 기준 주소 = 물리 주소의 시작점) 값을 더하여** 논리 주소를 물리 주소로 변환

<aside>
❗ 다른 프로그램을 침범하는 주소 보내면 안 된다!

![메모장의 프로그램 논리 주소를 초과해버리는 예시 이미지
⇒ **안전하지 못하다.** 다른 프로그램의 데이터에 큰 문제 발생 가능성](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%206%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%8F%E1%85%A2%E1%84%89%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20450269d12b9146e3b6c066b7e0bded18/Untitled%205.png)

메모장의 프로그램 논리 주소를 초과해버리는 예시 이미지
⇒ **안전하지 못하다.** 다른 프로그램의 데이터에 큰 문제 발생 가능성

</aside>

### 메모리 보호

명령어가 다른 프로그램의 영역을 침범하지 않도록 보호 조치가 필요!

**한계 레지스터**

- 프로그램의 영역을 **침범할 수 있는 명령어 실행을 막음**
- 베이스 레지스터가 실행 중인 프로그램의 가장 작은 물리 주소를 저장, **한계 레지스터는 논리 주소의 최대 크기를 저장**
- 베이스 레지스터 ≤ 프로그램의 물리 주소 범위 <베이스 레지스터 + 한계 레지스터 값
- CPU는 **메모리 접근 전**에, 논리 주소가 한계 레지스터보다 작은지 항상 검사 후 다른 프로그램의 주소 공간 침범 시에 인터럽트 발생!

## 캐시 메모리

**CPU가 메모리에 접근하는 속도는 CPU 연산 속도보다 압도적으로 느리다!**

### 저장 장치 계층 구조

1. CPU와 가까운 저장 장치는 빠르고, 멀리 있는 저장 장치는 느리다.
2. 속도가 빠른 저장 장치는 저장 용량이 작고, 비싸다.

이전에 학습한 레지스터와 RAM의 특징 차이를 되짚어보자! 이들 역시, 해당 이론을 따르고 있다.

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%206%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%8F%E1%85%A2%E1%84%89%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20450269d12b9146e3b6c066b7e0bded18/Untitled%206.png)

### 캐시 메모리

- **CPU와 메모리 사이**에 위치
- **레지스터보다 용량이 크고 메모리보단 빠른 SRAM**(정적 RAM) 기반의 저장 장치
- CPU의 연산 속도와 메모리 접근 속도의 차이를 줄이기 위해 탄생
- 메모리에서 CPU가 사용할 일부 데이터를 미리 캐시 메모리로 가져와 쓰기
- 현대 CPU는 대부분 캐시 메모리를 사용
- 캐시 메모리 중 CPU 내부에 있는 것도 존재, 그래도 레지스터가 더 빠르다!

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%206%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%8F%E1%85%A2%E1%84%89%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20450269d12b9146e3b6c066b7e0bded18/Untitled%207.png)

- 캐시 메모리는 하나만 있는 것이 아닌, 일반적으로 계층적으로 존재(=**계층적 캐시 메모리**, L1-L2-L3 캐시)
    - 일반적으로 **L1, L2 캐시는 CPU 코어 내부**, **L3는 코어 외부에 존재**
    - 용량: L1<L2<L3
    - 속도: L1>L2>L3

![계층적 캐시 메모리 구조](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%206%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%8F%E1%85%A2%E1%84%89%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20450269d12b9146e3b6c066b7e0bded18/Untitled%208.png)

계층적 캐시 메모리 구조

![멀티 코어 프로세스의 경우, 일반적인 양상(멀티 코어의 경우 L1, L2 들의 데이터 일관성, 싱크를 맞추는 것이 중요)](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%206%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%E1%84%8B%E1%85%AA%20%E1%84%8F%E1%85%A2%E1%84%89%E1%85%B5%20%E1%84%86%E1%85%A6%E1%84%86%E1%85%A9%E1%84%85%E1%85%B5%20450269d12b9146e3b6c066b7e0bded18/Untitled%209.png)

멀티 코어 프로세스의 경우, 일반적인 양상(멀티 코어의 경우 L1, L2 들의 데이터 일관성, 싱크를 맞추는 것이 중요)

- 속도를 더 빠르게 하기 위한 **분리형 캐시**도 존재
    - L1D, L1I 처럼 데이터만 담는 캐시 메모리, 명령어만 담기 위한 캐시 메모리로 분리

### 참조 지역성의 원리

캐시 메모리는 메모리보다 용량이 작기 때문에 **메모리의 모든 내용은 저장이 불가능! 일부 내용만 저장 가능**

그렇다면 어떤 걸 가져와야 할까?

⇒ **CPU가 자주 사용할 법한 내용을 예측** 저장 

**캐시 히트** = 캐시 메모리에 저장된 것을 CPU가 활용 = 예측 성공

**캐시 미스** = 예측 실패 → 성능 하락

**캐시 적중률** = 캐시 히트 횟수 / (캐시 히트 횟수 + 미스 횟수)

요즘 CPU의 캐시 적중률은 못해도 80 이상…

그런데 CPU는 어떻게 예측할까?

 ⇒ **참조 지역성의 원리**

- **CPU가 메모리에 접근할 때의 주 경향을 바탕**으로 만들어진 원리
    1. CPU가 최근에 접근했던 **메모리 공간에 재접근**하려는 경향이 있다.
        1. 흔히 프로그래밍 시 사용하는 변수 접근
    2. CPU가 접근한 메모리 **공간 근처**를 접근하려는 경향이 있다. (=공간 지역성)