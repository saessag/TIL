# 섹션 4. CPU의 작동원리

## ALU와 제어 장치

### ALU

ALU: 계산 장치

제어 장치: 제어 신호 발생, 명령어 해석

![ALU가 받아들이는 정보들](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%204%20CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20c70de64317864646b7cbc31c758783f9/Untitled.png)

ALU가 받아들이는 정보들

ALU는 레지스터로부터 피연산자를 받아들이고 제어 장치로부터 신호를 받아 그 결과 값을 **레지스터**에 저장한다.

왜 레지스터에 저장? ⇒ 메모리보다 레지스터에 접근하는 속도가 더 빠르니까!

### **플래그 레지스터**: 연산 결과에 대한 부가 정보

플래그 레지스터에는 결과의 음수, 양수 판별 외에도 연산 결과값이 너무 큰 경우, 오버플로우를 명시하는 등 다양한 역할이 있다.

CPU마다 플래그 레지스터가 다르지만 공통적인 플래그는 아래와 같다.

**부호 플래그** - 연산 결과의 부호 나타냄

**제로 플래그** - 연산 결과가 0인지 여부

**캐리 플래그** - 연산 결과 올림수나 빌림수가 발생했는지 여부

**오버플로우 플래그** - 오버플로우가 발생했는지 여부

**인터럽트 플래그** - 인터럽트가 가능한지 여부

**슈퍼바이저 플래그** - 커널 모드, 사용자 모드 중 어느 실행인지 나타냄

### 제어장치

![제어장치가 받아들이고 내보내는 정보](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%204%20CPU%E1%84%8B%E1%85%B4%20%E1%84%8C%E1%85%A1%E1%86%A8%E1%84%83%E1%85%A9%E1%86%BC%E1%84%8B%E1%85%AF%E1%86%AB%E1%84%85%E1%85%B5%20c70de64317864646b7cbc31c758783f9/Untitled%201.png)

제어장치가 받아들이고 내보내는 정보

**클럭**: 컴퓨터의 모든 부품을 움직일 수 있게 하는 시간 단위

**클럭 주기**

**명령어 레지스터:** 해석할 명령어 받음

**플래그 레지스터:** 명령어 레지스터를 받을 때의 부가정보도 함께 필요

**제어신호**: 제어 버스로부터 제어 신호도 받는다

## 레지스터

CPU 내부의 임시저장 장치

프로그램 속 명령어와 데이터는 실행 전후로 레지스터에 저장

CPU 내부에는 다양한 레지스터가 존재, 각 역할이 다르다!

### 필수로 알아야 할 레지스터들

1. **프로그램 카운터**
    - 메모리에서 가져올 명령어 주소
    - 메모리 주소 레지스터로 명령어 주소를 복사하고 결과 데이터가 메모리 버퍼 레지스터 → 명령어 레지스터로 도착하면 **카운터가 1 증가**
    - **무조건 1씩 순차적 진행은 아니다!** 특정 메모리 주소로 실행 흐름의 이동 가능성(JUMP, CONDITIONAL JUMP, CALL, RET) + 인터럽트 + ETC
2. **명령어 레지스터**
    - 해석할 명령어(방금 메모리에서 읽어 들인 명령어) → 제어장치가 이를 해석
3. **메모리 주소 레지스터**
    - 메모리의 주소 → CPU가 읽어 들이고자 하는 주소를 주소 버스로 보낼 때 거치는 레지스터
4. **메모리 버퍼 레지스터**
    - 메모리와 주고받을 값(데이터와 명령어) → CPU가 정보를 데이터 버스로 주고받을 때 거치는 레지스터
5. **플래그 레지스터**
    - 연산 결과 또는 CPU 상태에 대한 부가적 정보
6. **범용 레지스터**
    - 다양하고 일반적인 상황에서 자유롭게 사용
7. **스택 포인터**
    - 특별한 주소 지정(스택 주소 지정 방식)에 사용
    - 참고로 스택 자체는 메모리 안의 스택 영역에 있다!
8. **베이스 레지스터**
    - 특별한 주소 지정(변위 주소 지정 방식)에 사용

## 명령어 사이클과 인터럽트

### 인터럽트의 정의

CPU는 메모리 안에 있는 프로그램을 일정한 주기로 정해진 흐름대로 처리하는 **명령어 사이클**이 존재. 이 사이클을 중단시키는 신호가 인터럽트

### 명령어 사이클의 순서

1. 인출 사이클:  메모리로부터 CPU 내부로 인출하는 사이클
2. 실행 사이클: 가져온 것을 실행하는 사이클

인출 → 실행 → 인출 … 의 반복!

간접 주소 지정 방식처럼, 명령어를 가지고 와도 바로 실행이 불가능하다면? → 이를 위한 **간접 사이클**이 존재

간접 사이클은 **항상 존재하는 것이 아닌**, 실행에 **메모리 접근이 더 필요한 경우에 인출 → 간접 → 실행** 의 방향으로 사이클이 돈다!

### 인터럽트의 발생원인과 종류

CPU가 꼭 주목해야 할 때, 즉시 처리해야 할 다른 작업이 생겼을 때 발생

1. **동기 인터럽트**(예외/EXCEPTION): CPU가 예기치 못한 상황을 접했을 때 발생
    1. 폴트
    2. 트랩
    3. 중단
    4. 소프트웨어 인터럽트 
2. **비동기 인터럽트**(하드웨어 인터럽트): 주로 입출력장치에 의해 발생. 알림 같은 역할(EX)전자레인트 조리 알림)

### 하드웨어 인터럽트의 의의와 순서

알림의 용도인 인터럽트를 굳이 왜 사용할까?

⇒ **입출력 작업 도중에도 효율적인 명령어 처리를 위함.** 

**입출력 장치는 CPU에 비해 느리기 때문에**, 인터럽트가 없으면 입출력 장치의 완료 여부를 수시로 확인해야 한다! 하지만 하드웨어 인터럽트를 통해, 입출력 장치가 완료여부를 알릴 때 까지 CPU는 다른 작업을 할 수 있다.

1. 입출력장치가 CPU에 **인터럽트 요청 신호** 전달
2. CPU는 실행 사이클이 끝나고 명령어 인출 사이클 전에 인터럽트 여부 확인
3. CPU는 인터럽트 요청 확인 후, **인터럽트 플래그**를 통해 현재 인터럽트를 받을 수 있는지 여부 확인
4. 인터럽트를 받을 수 있으면 지금까지의 작업을 CPU가 **스택 영역**에 백업
5. CPUS는 **인터럽트 벡터**(인터럽트마다 가진 각각의 고유 주소와 정보)를 참조해 **인터럽트 서비스 루틴**(EX)키보드가 인터럽트 요청 시 행동지침) 실행
6. 인터럽트 서비스 루틴이 완료되면 **백업해 둔 작업을 복구 및 실행 재개**

<aside>
⚠️ 단, 하드웨어 인터럽트는 인터럽트 플래그로 **막을 수 있는 인터럽트**와 **막을 수 없는 인터럽트**(하드웨어 고장, 정전 등의 긴급 상황)로 분류가 된다.

**인터럽트 서비스 루틴도 프로그램! 즉, 메모리에 저장되어 있음.**

</aside>