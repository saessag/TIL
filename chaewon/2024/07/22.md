# 리눅스 마스터 2급

### 1-1 리눅스개요 학습 및 기출문제 풀이

---

# 섹션 10. 프로세스와 스레드

## 프로세스 개요

### 프로세스 - 실행중인 프로그램

윈도우 사용 시 작업 관리자로 쉽게 확인 가능!

### 프로세스 종류

- **포그라운드 프로세스**
    - 사용자가 볼 수 있는 공간에서 실행되는 프로세스
- **백그라운드 프로세스**
    - 사용자가 볼 수 없는 공간에서 실행되는 프로세스
    - 사용자와 직접 상호작용 가능한 백그라운드 프로세스
    - 사용자와 상호작용하지 않고 정해진 일만 수행하는 프로세스(=**데몬** =**서비스**)

### 운영체제의 프로세스 관리

**프로세스 제어 블록(PCB)**

- 모든 프로세스는 실행을 위해 CPU가 필요
- 하지만 CPU 자원은 **한정적**
- 프로세스들은 돌아가며 한정된 시간 만큼만 CPU 이용
    - 자신의 차례에 정해진 시간만 CPU 이용!
    - **타이머 인터럽트**(= 클럭 신호를 발생시키는 장치에 의해 주기적으로 발생하는 하드웨어 인터럽트 = 타임아웃 인터럽트)가 발생 시 차례 이동
- 빠르게 번갈아 수행되는 프로세스를 관리하는 것이 프로세스 제어 블록(**PCB**)
    - 프로세스 관련 정보를 저장하는 자료 구조
    - LIKE 상품에 달리 태그
    - **프로세스 생성 시 커널 영역에 생성, 종료 시 폐기**

**PCB에 담기는 대표적 정보**

- 프로세스 ID(PID)
    - 특정 프로세스를 식별하기 위한 식별값
    
    ![실제 작업관리자 화면](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2010%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%2093b7690aa65e42bc96456c748dd037e8/Untitled.png)
    
    실제 작업관리자 화면
    
- 레지스터 값
    - 자기 차례에 올 때마다 프로세스가 연산을 처음부터 다시 시작한다면 굉장히 무의미한 작업…
    - 번갈아 실행하기 위해서는 그동안 실행한 만큼의 진척도(프로그램 카운터, 중간 연산 결과, 스택 포인터 등…)를 기억하고 있어야 한다!
    - 즉, 프로세스는 이전 까지 사용한 **레즈스터 중간 값**을 모두 복원 후 갖고 있음
- 프로세스 상태
    - 입출력 장치를 사용하기 위한 상태, CPU 사용 대기 상태 등
- CPU 스케줄링 정보 (후반 강의)
    - 프로세스가 CPU를 언제 어떤 순서로 할당받을지에 대한 정보
- 메모리 정보
    - 프로세스가 어느 주소에 저장되어 있는지에 대한 정보
    - 페이지 테이블 정보
- 사용한 파일과 입출력장치 정보
    - 할당된 입출력장치, 사용 중인 열린 파일 정보

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2010%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%2093b7690aa65e42bc96456c748dd037e8/Untitled%201.png)

### 문맥 교환

> 한 프로세스에서 다른 프로세스로 실행 순서가 넘어간다면?

⇒ 기존 프로세스 A는 중간 정보( == 문맥) 백업
⇒ 다음에 실행할 프로세스의 문맥을 복구 후 프로세스 교체 후 실행
> 

위 과정이 **문맥 교환**

여러 프로세스가 끊임없이 빠르게 실행될 수 있는 원리

### 프로세스의 메모리 영역 중 사용자 영역

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2010%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%2093b7690aa65e42bc96456c748dd037e8/Untitled%202.png)

크게 아래 4가지로 나뉜다.

- **코드 영역(= 텍스트 영역)**
    - 실행할 수 있는 코드, **기계어로 이루어진 명령어** 저장
    - 데이터가 아닌 CPU가 실행할 명령어가 담기기에 쓰기 금지 영역(**read-only**)
    - 크기가 고정된 영역(= **정적 할당** 영역)
- **데이터 영역**
    - 잠깐 썼다가 사라질 데이터가 아닌 프로그램이 실행되는 동안 유지할 데이터가 저장(= **전역 변수**)
    - 크기가 고정된 영역(= **정적 할당** 영역)
- **힙 영역**
    - 프로그램을 만드는 사용자, 즉 프로그래머가 직접 할당할 수 있는 저장공간
    - 사용한 공간은 다시 반환해야 함. 그렇지 못하면 메모리 누수
    - 자동으로 해주는 언어도 존재. (가비지 컬렉터가 수행)
    - **동적 할당** 영역
    - 일반적으로 낮은 주소 → 높은 주소로 할당
- **스택 영역**
    - 데이터가 일시적으로 저장되는 공간
    - 잠깐 쓰고 사라질 값들이 저장
    - 매개 변수, 지역 변수
    - **동적 할당** 영역
    - 일반적으로 높은 주소 → 낮은 주소로 할당

## 프로세스 상태와 계층 구조

### 프로세스 상태

가끔씩, 혹은 흔히 보는 …이 응답하지 않습니다. 라는 메세지를 본 적이 있을 것이다.

이 메세지 또한 프로세스 상태 중 하나!

이런 프로세스 상태들을 PCB에 기록.

- **생성 상태**
    - 이제 막 메모리에 적재되어 PCB를 할당 받은 상태
    - 준비 완료 시 준비 상태
- **준비 상태**
    - 당장이라도 CPU를 할당 받아 실행 가능
    - 하지만 자신 차례가 아니기에 기다리는 상태
    - 자기 차례가 되면 실행 상태 (= **디스패치**)
- **실행 상태**
    - CPU를 할당 받아 실행 중인 상태
    - 할당된 시간 모두 사용 시 준비 상태
    - 실행 도중 입출력장치 사용 시, 입출력 작업이 끝날 때까지 대기 상태
- **대기 상태**
    - 프로세스가 실행 도중 입출력장치를 사용하는 경우
    - 입출력 작업은 CPU에 비해 느리기에 대기 상태로
    - 입출력 작업이 끝나면(입출력 완료 인터럽트) 준비 상태
- **종료 상태**
    - 프로세스가 종료된 상태
    - PCB, 프로세스의 메모리 영역 정리
    
    ![프로세스 상태 도식화](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2010%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%2093b7690aa65e42bc96456c748dd037e8/Untitled%203.png)
    
    프로세스 상태 도식화
    

### 프로세스 계층 구조

대부분의 운영체제들은 프로세스를 계층적으로 관리

엄밀하게 따지면 윈도우는 계층적 관리 X

- 프로그램 실행 도중 **시스템 호출**을 통해 다른 프로세스 생성 가능
- **부모 프로세스**: 새 프로세스를 생성한 프로세스
- **자식 프로세스**: 부모 프로세스에 의해 생성된 프로세스
- 부모 프로세스와 자식 프로세스는 별개의 프로세스
    
    ⇒ 각자 다른 PID
    
- 일부 운영체제에서는 자식 프로세스 PCB에 부모 프로세스의 PID(=PPID)를 명시
- 자식 프로세스는 또 새로운 자식 프로세스 생성 가능
    
    ⇒ 프로세스의 계층적 구조
    

![프로세스 계층 구조의 예시](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2010%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%2093b7690aa65e42bc96456c748dd037e8/Untitled%204.png)

프로세스 계층 구조의 예시

### 프로세스 생성 기법

윈도우는 관련 없음! 단, 개발 시 리눅스를 주로 사용하므로 잘 알아두자

> 부모 프로세스는 어떻게 자식 프로세스를 생성?
자식 프로세스는 어떻게 자신만의 코드를 실행?
> 

⇒ LIKE 복제와 옷 갈아입기

- 부모 프로세스는 **fork 시스템 호출**을 통해 자신의 복사본을 자식 프로세스로 생성 (복제)
    - fork 시스템 호출
        - 복사본(=자식 프로세스) 생성
        - 부모 프로세스의 자원 상속
        - 별개 프로세스라는 것은 변치 않으므로 PID와 메모리 위치는 다르다
- 자식 프로세스는 **exec 시스템 호출**을 통해 자신의 메모리 공간을 다른 프로그램으로 교체 (옷 갈아입기, 자신만의 코드 실행)
    - exec 시스템 호출
        - 메모리 공간을 새로운 프로그램으로 덮어쓰기
        - 코드와 데이터 영역은 실행할 프로그램 내용으로 바뀌고 나머지 영역은 초기화

![fork와 exec](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2010%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%2093b7690aa65e42bc96456c748dd037e8/Untitled%205.png)

fork와 exec

## 스레드

이 섹션에서는 소프트웨어 스레드에 대해 설명한다.

### 스레드

프로세스를 구성하는 **실행 흐름의 단위** 

하나의 프로세스는 하나 이상의 스레드를 가질 수 있다.

**단일 스레드 프로세스**

- 실행 흐름이 하나인 프로세스

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2010%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%2093b7690aa65e42bc96456c748dd037e8/Untitled%206.png)

**멀티 스레드 프로세스**

- 실행 흐름이 여러 개인 프로세스
    
    ⇒ 프로세스를 이루는 여러 명령어 동시 실행 가능
    
- 보통 프로그램들은 거의 다 멀티 스레드 프로세스

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2010%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%2093b7690aa65e42bc96456c748dd037e8/Untitled%207.png)

### 스레드의 구성 요소

- 스레드 ID
- 프로그램 카운터를 비롯한 레지스터 값
- 스택
- etc..
- 실행에 필요한 최소한의 정보

각각의 **스레드들이 병행해 실행**하지만, 이 스레드들은 **자원을 공유**한다!

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2010%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%2093b7690aa65e42bc96456c748dd037e8/Untitled%208.png)

스레드 1의 코드 영역, 데이터 영역이 별도로 존재하는 것이 아니다!

전통적으로는 CPU에게 프로세스 단위로 전달한다고 하지만, 요즘은 대부분 스레드 단위로 전달한다.

### 멀티 프로세스와 멀티 스레드

> 동일 작업을 수행하는 **단일 스레드 프로세스 N개**
VS
하나의 프로세스를 **복수 스레드**로 실행
> 

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2010%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%2093b7690aa65e42bc96456c748dd037e8/Untitled%209.png)

- **프로세스 포크**: 프로세스 fork 시 **코드/데이터/힙 영역 등 모든 자원이 복제** 저장!
- 저장된 메모리 주소를 제외하면 모든 것이 동일한 프로세스 두 개가 통째로 메모리에 적재
    
    <aside>
    ❗ 사실, fork 직후 동일 프로세스를 통째로 메모리에 중복 저장하지 않으면서 동시에 프로세스끼리 자원을 공유하지 않는 방법도 있다.
    = **쓰기 시 복사 기법**
    
    </aside>
    
- 프로세스 끼리는 자원을 공유하지 않고 스레드끼리는 자원을 공유한다.
- 즉 스레드 ID와 별도 실행에 꼭 필요한 프로그램 카운터 값을 포함한 레지스터 값, 스택 외에는 **프로세스 자원을 공유!**
    
    → **협력과 통신에 유리**하지만 때로는 문제가 될수도…
    

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%2010%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%E1%84%8B%E1%85%AA%20%E1%84%89%E1%85%B3%E1%84%85%E1%85%A6%E1%84%83%E1%85%B3%2093b7690aa65e42bc96456c748dd037e8/Untitled%2010.png)

<aside>
❗ 프로세스끼리는 자원을 공유하지 않는다고 하지만, 사실 주고 받을 수 있다! (프로세스 간 통신, IPC) 단, 스레드 간의 통신보다 어려울 뿐…

파일을 통한 프로세스 간 통신, 공유 메모리를 통한 프로세스 간 통신

</aside>