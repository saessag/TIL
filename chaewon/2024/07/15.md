# 섹션 5. CPU를 위한 설계 기법

## 빠른 CPU를 위한 설계 기법

### 클럭(클럭 속도)

컴퓨터 부품들은 클럭 신호에 맞춰 일사불란하게 움직임

CPU는 명령어 사이클이라는 정해진 흐름에 맞춰 명령어를 실행한다.

⇒ 클럭 신호가 빠르게 반복(=빠른 클럭 속도)되면 컴퓨터 부품들은 그만큼 빠른 박자에 맞춰 움직인다.(항상은 아니고 일반적으로!)

**클럭 속도**: 헤르츠(1초에 클럭이 반복되는 횟수) 단위로 측정

하지만 클럭 신호가 필요 이상으로 빨라지면 발열이 심해진다! (고사양의 프로그램을 돌릴 때 많이 경험하는 그것…)

### 코어? 멀티코어?

클럭 속도만 늘려서는 CPU 성능의 무조건적인 돌파구가 되지 않는다! 이 외에 고려할 것은 코어 수와, 스레드 수.

![CPU  성능의 표기의 예시(코어 8개, 스레드 16개)](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%205%20CPU%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A5%E1%86%B8%20ea0ea5d6cd4d443bb9abec35b5008122/Untitled.png)

CPU  성능의 표기의 예시(코어 8개, 스레드 16개)

### 코어

- CPU의 용어를 현대적 관점에서 재해석 필요
- 전통적으로 명령어를 실행하는 부품은 원칙적으로 하나만 존재했지만, 오늘날은 아니다! **복수의 명령어 실행 부품**이 존재한다!
- ‘**명령어를 실행하는 부품’ == 코어**

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%205%20CPU%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A5%E1%86%B8%20ea0ea5d6cd4d443bb9abec35b5008122/Untitled%201.png)

**멀티 코어**: 코어가 2개 이상

**듀얼 코어**: 코어가 2개

…

하지만, 꼭 **코어 수에 비례해 연산 속도가 증가하지는 않는다.** 작업을 각 코어에 효율적으로 나누는 것도 중요…(조별과제 st.)

### 스레드

실행 흐름의 단위, 라고 정의되지만 다양한 곳에서 사용하는 언어

따라서 우리는 아래와 같은 구분이 필요

- **하드웨어적 스레드**
    - 하나의 코어가 동시에 처리하는 명령어 단위
        - 하나의 코어가 한번에 하나의 명령어 실행 → 1코어 1스레드 CPU
        - CPU 내부 코어가 2개(듀얼 코어)이고 각 2개의 명령어 동시 실행 → 2코어 4스레드 CPU
        - 위의 조별과제 예시에서, 한 명의 사람이 동시에 멀티태스킹하는 업무 능력 정도로 비유
        - **멀티스레드 프로세서**: 하나의 코어가 여러 개의 명령어를 동시에 처리가능 한 프로세서
            - 멀티스레드 프로세스의 큰 핵심은 **레지스터**
            - 핵심 레지스터(프로그램 카운터, 스택 카운터 등…)들을 하나의 코어가 복수 포함
    - **논리 프로세서**라고도 한다.
- **소프트웨어적 스레드**
    - 하나의 프로그램에서 **독립적으로 실행하는 단위**
        
        ![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%205%20CPU%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A5%E1%86%B8%20ea0ea5d6cd4d443bb9abec35b5008122/Untitled%202.png)
        
        ![멀티스레드 기능의 예시(동시에 3개의 실행 흐름)](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%205%20CPU%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A5%E1%86%B8%20ea0ea5d6cd4d443bb9abec35b5008122/Untitled%203.png)
        
        멀티스레드 기능의 예시(동시에 3개의 실행 흐름)
        
    - 하나의 프로그램으로 동시에 여러 군데 실행

<aside>
❓ DOCS 프로그램 등을 사용하다보면, 자동 저장, 맞춤법 검사 등의 다양한 작업이 동시 진행하고 있다.
하지만, 하드웨어적 스레드에서 1코어 1스레드 CPU는 한번에 하나의 명령어만 처리할 수 있다고 했기에 실행에 문제가 생길 수 있지 않냐는 의문이 발생할 수 있다!

**⇒ 1코어 1스레드 CPU도 여러 개의 소프트웨어 스레드를 만들 수 있다!
⇒ CPU는 내부적으로 여러 개의 프로그램이나 스레드 실행 시, 진짜로 동시에 일괄 실행하는 것이 아닌 빠른 속도로 번갈아 작업한다. 즉, 동시에 실행하는 것 같은 느낌이 드는 것이다!**

</aside>

## 명령어 병렬 처리 기법

메모리에 쌓인 명령어 집합들을 CPU가 어떻게 효율적으로, 빠르게 처리할 수 있을까?

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%205%20CPU%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A5%E1%86%B8%20ea0ea5d6cd4d443bb9abec35b5008122/Untitled%204.png)

### 명령어 파이프라인 방식

이전 섹션에서 명령어 사이클은 인출 → 실행 두 단계로 진행한다고 했지만, 전공서적에 따라 아래와 같이 나누기도 한다.

1. **명령어 인출**
2. **명령어 해석**
3. **명령어 실행**
4. **결과 저장**

> 같은 단계만 겹치지 않으면 **CPU는 각 단계를 동시에 진행**할 수 있다!!
> 
> 
> ![t2 동안, 명령어 1을 실행, 명령어 2를 해석, 명령어 3은 인출⇒명령어 파이프라인의 예시](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%205%20CPU%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A5%E1%86%B8%20ea0ea5d6cd4d443bb9abec35b5008122/Untitled%205.png)
> 
> t2 동안, 명령어 1을 실행, 명령어 2를 해석, 명령어 3은 인출⇒명령어 파이프라인의 예시
> 

명령어 파이프라인은 컨베이어 벨트 같은 구조라고 생각할 수 있다!

### 파이프라인 위험

**명령어 파이프라인이 성능 향상에 실패하는 경우**

위 사진과 같은 예시는 이상적인 예시이다. 동시에 명령어 처리가 불가능한 경우 3가지를 보자.

- **데이터 위험**
    - 명령어 간의 의존성에 의한 위험
    - **이전 명령어를 반드시 끝까지 완수해야 실행할 수 있는 경우**
    - ex) 명령어 1:  R1 ← R2 + R3 / 명령어 2: R4 ← R1 + R5
        
        ⇒ 이 경우, 명령어 2의 R1은 명령어 1이 완수되지 않으면 불러올 수가 없다!
        
- **제어 위험**
    - **프로그램 카운터의 갑작스러운 변화**에 의한 위험
    - 프로그램 카운터가 특정 메모리 주소로 실행 흐름이 변경되는 경우(JUMP 등의 명령어)
    
    ⇒ 이런 경우 순차적으로 진행하던 이후 명령어들은 인출, 해석한 의미가 없어진다.
    
    ![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%205%20CPU%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A5%E1%86%B8%20ea0ea5d6cd4d443bb9abec35b5008122/Untitled%206.png)
    
- **구조적 위험**
    - **서로 다른 명령어가 같은 CPU 부품을 쓰려고 할 때 발생하는 위험**

### 슈퍼 스칼라

**CPU 내부에 여러 개의 명령어 파이프라인을 포함**한 구조(멀티스레드 프로세서에서 사용 가능!)

![Untitled](%E1%84%89%E1%85%A6%E1%86%A8%E1%84%89%E1%85%A7%E1%86%AB%205%20CPU%E1%84%85%E1%85%B3%E1%86%AF%20%E1%84%8B%E1%85%B1%E1%84%92%E1%85%A1%E1%86%AB%20%E1%84%89%E1%85%A5%E1%86%AF%E1%84%80%E1%85%A8%20%E1%84%80%E1%85%B5%E1%84%87%E1%85%A5%E1%86%B8%20ea0ea5d6cd4d443bb9abec35b5008122/Untitled%207.png)

이론적으로는 **파이프라인 개수에 비례해 처리 속도 증가**. 하지만 **그만큼 파이프라인 위험도가 증가**하기 때문에 실제로는 비례 증가는 아니다!

### 비순차적 명령어 처리 방식

합법적이 새치기…

파이프라인 중단을 방지하기 위해 명령어를 의도적으로 **비순차적**으로 처리

<aside>
❓ 명령어 순서를 임의적으로 바꾸면 프로그램이 오류나지 않을까?
→ 당연히 이를 방지하기 위해, 전체 프로그램 실행 흐름에는 영향이 없는 비 의존적 명령어의 순서를 바꾼다! (보통 판단은 CPU가 다 알아서 해준다)

</aside>

## 명령어 집합 구조, CISC와 RISC

우선 CPU가 실행하는 명령어는 CPU마다 생김새(연산, 주소지정방식 등…)가 다르다.

### 명령어 집합(ISA)

**CPU가 이해할 수 있는 명령어들의 모음**, CPU의 언어

CPU마다 이해할 수 있는 명령어 집합이 다르다 → 인텔 CPU 컴퓨터에서 만든 실행 파일을 바로 아이폰에 옮겨 실행하면 실행이 안 된다.

명령어가 달라지면, 많은 것이 달라진다. 해석 방식, 레지스터 종류와 개수, 파이프라이닝의 용이성 등…

⇒ ISA는 하드웨어가 소프트웨어를 어떻게 이해할 지에 대한 약속

현대의 명령어 집합의 양대산맥은 CISC와 RISC

### CISC

- **복잡한 명령어 집합**을 활용하는 컴퓨터(CPU)
- x86, x86-64
- **복잡하고 다양한 명령어**
- 명령어의 형태와 크기가 다양한 **가변 길이 명령어** 사용
- 다양하고 강력한 명령어
- 상대적으로 적은 명령어들로 프로그램 실행 가능
- 큰 단점: **명령어 파이프라이닝에 불리!**
    - 명령어가 복잡하고 다양한 기능을 제공하기 때문에 명령어의 크기와 실행 시간이 일정하지 못함
    - 명령어 하나 실행하는 데에 여러 클럭 주기 필요
- 단점: **대다수의 복잡한 명령어는 사실 사용 빈도가 낮다.**

### RISC

- **명령어 종류가 적고**, 짧고 **규격화된 명령어** 사용
- **메모리 접근 최소화**
- **레지스터를 최대한 활용**
- 단점: 더 많은 명령어로 프로그램이 실행된다.