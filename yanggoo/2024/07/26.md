# 2024ë…„ 07ì›” 26ì¼
- ë¦¬ë•ìŠ¤ì—ì„œ ë¹„ë™ê¸°ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²• ë°°ìš°ê¸° 2
- ë¦¬ë•ìŠ¤ì˜ í•¨ìˆ˜ íŒŒí—¤ì³ ë³´ê¸°

# Reduxì™€ Async Logic

## asyncFunctionMiddleware

```js
// asyncFunctionMiddleware.js
const asyncFunctionMiddleware = store => next => action => {
  if (typeof action === 'function') {
    return action(store.dispatch, store.getState);
  }
  return next(action);
};

export default asyncFunctionMiddleware;
```

```js
// store.ts
import { applyMiddleware, compose, createStore } from 'redux';
import rootReducer from './reducers';
import asyncFunctionMiddleware from './middlewares/asyncFunctionMiddleware';

/**
 * ë¸Œë¼ìš°ì € í™•ì¥í”„ë¡œê·¸ë¨ì— REDUX_DEVTOOLSê°€ ì„¤ì¹˜ë˜ì–´ ìˆìœ¼ë©´ DEVTOOLSì˜ compose ì‹¤í–‰
 * ì•„ë‹ˆë¼ë©´ Reduxì˜ compose í•¨ìˆ˜ ì‹¤í–‰
 */
const composeEnhancers =
  (window as any).__REDUX_DEVTOOLS_EXTENSION_COMPOSE__ || compose;

const store = createStore(
  rootReducer,
  composeEnhancers(applyMiddleware(asyncFunctionMiddleware))
);

export default store;
```

## enhancer

- ë¦¬ë•ìŠ¤ì—ì„œ ìŠ¤í† ì–´ì˜ ê¸°ëŠ¥ì„ í™•ì¥í•˜ê±°ë‚˜ ê°œì„ í•˜ê¸° ìœ„í•´ ì‚¬ìš©í•˜ëŠ” ê³ ì°¨ í•¨ìˆ˜(Higher-Order Function)ë¥¼ ì˜ë¯¸
- compose, applyMiddleware ë“±ë“±
- ê³ ì°¨ í•¨ìˆ˜(Higher-Order Function)ë€ í•¨ìˆ˜ë¥¼ ì¸ìë¡œ ì „ë‹¬ë°›ê±°ë‚˜ í•¨ìˆ˜ë¥¼ ê²°ê³¼ë¡œ ë°˜í™˜í•˜ëŠ” í•¨ìˆ˜

## Middleware

- ìƒˆë¡œìš´ ë””ìŠ¤íŒ¨ì¹˜ í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ê¸° ìœ„í•´ ë””ìŠ¤íŒ¨ì¹˜ í•¨ìˆ˜ë¥¼ êµ¬ì„±í•˜ëŠ” ê³ ì°¨ í•¨ìˆ˜
- ì‘ì—…ì„ ê¸°ë¡í•˜ê±°ë‚˜, ë¼ìš°íŒ…ê³¼ ê°™ì€ ë¶€ì‘ìš©ì„ ìˆ˜í–‰í•˜ê±°ë‚˜, ë¹„ë™ê¸° API í˜¸ì¶œì„ ì¼ë ¨ì˜ ë™ê¸° ì‘ì—…ìœ¼ë¡œ ì „í™˜í•˜ëŠ” ë° ìœ ìš©

### Middleware Type

```js
/**
* Middleware ì¸í„°í˜ì´ìŠ¤ëŠ” ë¯¸ë“¤ì›¨ì–´ í•¨ìˆ˜ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
* MiddlewareAPI ê°ì²´ë¥¼ ì¸ìˆ˜ë¡œ ë°›ì•„, next í•¨ìˆ˜ì™€ action í•¨ìˆ˜ë¥¼ ë°˜í™˜í•˜ëŠ” ê³ ì°¨ í•¨ìˆ˜ì…ë‹ˆë‹¤.
* next í•¨ìˆ˜ëŠ” ë‹¤ìŒ ë¯¸ë“¤ì›¨ì–´ ë˜ëŠ” ë¦¬ë“€ì„œë¡œ ì•¡ì…˜ì„ ì „ë‹¬í•©ë‹ˆë‹¤.
* action í•¨ìˆ˜ëŠ” ì•¡ì…˜ ê°ì²´ë¥¼ ì¸ìˆ˜ë¡œ ë°›ì•„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
*/
interface Middleware<_DispatchExt = {}, // TODO: see if this can be used in type definition somehow (can't be removed, as is used to get final dispatch type)
S = any, D extends Dispatch = Dispatch> {
    (api: MiddlewareAPI<D, S>): (next: (action: unknown) => unknown) => (action: unknown) => unknown;
}

/**
* MiddlewareAPI ì¸í„°í˜ì´ìŠ¤ëŠ” ë¯¸ë“¤ì›¨ì–´ í•¨ìˆ˜ê°€ ì ‘ê·¼í•  ìˆ˜ ìˆëŠ” ìŠ¤í† ì–´ ì¸í„°í˜ì´ìŠ¤ë¥¼ ì •ì˜í•©ë‹ˆë‹¤.
* ì—¬ê¸°ì—ëŠ” dispatch í•¨ìˆ˜ì™€ getState í•¨ìˆ˜ê°€ í¬í•¨ë©ë‹ˆë‹¤.
*/
interface MiddlewareAPI<D extends Dispatch = Dispatch, S = any> {
    dispatch: D;
    getState(): S;
}

/**
* Dispatch ì¸í„°í˜ì´ìŠ¤ëŠ” ì•¡ì…˜ì„ ë””ìŠ¤íŒ¨ì¹˜í•˜ëŠ” í•¨ìˆ˜ íƒ€ì…ì„ ì •ì˜í•©ë‹ˆë‹¤.
* ì•¡ì…˜ì„ ì¸ìˆ˜ë¡œ ë°›ì•„ì„œ ë””ìŠ¤íŒ¨ì¹˜í•˜ë©°, ë””ìŠ¤íŒ¨ì¹˜ëœ ì•¡ì…˜ì„ ë°˜í™˜í•©ë‹ˆë‹¤.
*/
interface Dispatch<A extends Action = UnknownAction> {
    <T extends A>(action: T, ...extraArgs: any[]): T;
}

/**
* UnknownAction ì¸í„°í˜ì´ìŠ¤ëŠ” Action ì¸í„°í˜ì´ìŠ¤ë¥¼ í™•ì¥í•˜ì—¬ ì¶”ê°€ì ì¸ ì„ì˜ì˜ ì†ì„±ì„ ê°€ì§ˆ ìˆ˜ ìˆìŠµë‹ˆë‹¤.
*/
interface UnknownAction extends Action {
    [extraProps: string]: unknown;
}

/**
* Action ì¸í„°í˜ì´ìŠ¤ëŠ” type ì†ì„±ì„ ê°–ëŠ” ê°ì²´ì…ë‹ˆë‹¤.
* ëª¨ë“  ì•¡ì…˜ ê°ì²´ëŠ” ìµœì†Œí•œ type ì†ì„±ì„ ê°€ì ¸ì•¼ í•©ë‹ˆë‹¤.
*/
type Action<T extends string = string> = {
    type: T;
};
```

## compose

- ë¦¬ë•ìŠ¤ì—ì„œ ì œê³µí•˜ëŠ” ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜, ì—¬ëŸ¬ í•¨ìˆ˜ë¥¼ ì¡°í•©í•˜ì—¬ í•˜ë‚˜ì˜ í•¨ìˆ˜ë¡œ ë§Œë“¤ì–´ì£¼ëŠ” ì—­í• 
- í•¨ìˆ˜ë“¤ì„ *ì˜¤ë¥¸ìª½ì—ì„œ ì™¼ìª½*ìœ¼ë¡œ ì°¨ë¡€ë¡œ ì‹¤í–‰

```js
// compose.ts
export default function compose(...funcs: Function[]) {
  if (funcs.length === 0) {
    // infer the argument type so it is usable in inference down the line
    return <T>(arg: T) => arg
  }

  if (funcs.length === 1) {
    return funcs[0]
  }

  return funcs.reduce(
    (a, b) =>
      (...args: any) =>
        a(b(...args))
  )
}
```

### compose example

```js
const composedFunction = compose(funcA, funcB, funcC);
// composedFunction()
// compose(funcA, funcB, funcC)
// (x) => funcA(funcB(funcC(x)))

const add5 = (x) => x + 5;
const multiply2 = (x) => x * 2;
const square = (x) => x * x;

const composedFunction = compose(add5, multiply2, square);
// composedFunction(2)
// square(2)ê°€ ë¨¼ì € ì‹¤í–‰ (2) => 2 * 2;
// square(2)ì˜ ì‹¤í–‰ ê²°ê³¼ì¸ 4ê°€ multiply2(4)ë¡œ ì‹¤í–‰ (4) => 4 * 2;
// multiply2(4)ì˜ ì‹¤í–‰ ê²°ê³¼ì¸ 8ì´ add5(8)ë¡œ ì‹¤í–‰ (8) => 8 + 5;
// add5(8)ì˜ ì‹¤í–‰ ê²°ê³¼ì¸ 13 ë¦¬í„´ (8) => 8 + 5;
```

### compose Type (function overloading)

```js
type Func<T extends any[], R> = (...a: T) => R;
/**
 * Composes single-argument functions from right to left. The rightmost
 * function can take multiple arguments as it provides the signature for the
 * resulting composite function.
 *
 * @param funcs The functions to compose.
 * @returns A function obtained by composing the argument functions from right
 *   to left. For example, compose(f, g, h) is identical to doing
 *   (...args) => f(g(h(...args))).
 */
declare function compose(): <R>(a: R) => R;
declare function compose<F extends Function>(f: F): F;
declare function compose<A, T extends any[], R>(f1: (a: A) => R, f2: Func<T, A>): Func<T, R>;
declare function compose<A, B, T extends any[], R>(f1: (b: B) => R, f2: (a: A) => B, f3: Func<T, A>): Func<T, R>;
declare function compose<A, B, C, T extends any[], R>(f1: (c: C) => R, f2: (b: B) => C, f3: (a: A) => B, f4: Func<T, A>): Func<T, R>;
declare function compose<R>(f1: (a: any) => R, ...funcs: Function[]): (...args: any[]) => R;
declare function compose<R>(...funcs: Function[]): (...args: any[]) => R;
```

## applyMiddleware

- Creates a store enhancer that applies middleware to the dispatch method of the Redux store.
- Redux ìŠ¤í† ì–´ì˜ ë””ìŠ¤íŒ¨ì¹˜ ë©”ì†Œë“œì— ë¯¸ë“¤ì›¨ì–´ë¥¼ ì ìš©í•˜ëŠ” ìŠ¤í† ì–´ ì¸í•¸ì„œë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
- ì—¬ëŸ¬ ê°œì˜ ë¯¸ë“¤ì›¨ì–´ë¥¼ ë°›ì•„ ì´ë¥¼ í•˜ë‚˜ì˜ ë¯¸ë“¤ì›¨ì–´ë¡œ ë¬¶ì–´ì£¼ëŠ” ì—­í• 

```js
export default function applyMiddleware(
  ...middlewares: Middleware[]
): StoreEnhancer<any> {
  return createStore => (reducer, preloadedState) => {
    const store = createStore(reducer, preloadedState)
    let dispatch: Dispatch = () => {
      throw new Error(
        'Dispatching while constructing your middleware is not allowed. ' +
          'Other middleware would not be applied to this dispatch.'
      )
    }

    // asyncFunctionMiddlewareì˜ store
    // const asyncFunctionMiddleware: Middleware = store =>
    const middlewareAPI: MiddlewareAPI = {
      getState: store.getState,
      dispatch: (action, ...args) => dispatch(action, ...args)
    }
    // 0 : next => {â€¦}
    // [next => {â€¦}]
    const chain = middlewares.map(middleware => middleware(middlewareAPI))
    dispatch = compose<typeof dispatch>(...chain)(store.dispatch)

    return {
      ...store,
      dispatch
    }
  }
}
```

#### P.S.
í•¨ìˆ˜ì˜ ì˜¤ë²„ë¡œë”©ì´ ì•„ì§ ìµìˆ™í•˜ì§€ ì•Šì•„ì„œ íƒ€ì…ê³¼ ì½”ë“œ íë¦„ì„ ëª¨ë‘ ì´í•´í•˜ì§„ ëª»í–ˆë‹¤. ğŸ¥²   
applyMiddleware í•¨ìˆ˜ê°€ ì–´ë–»ê²Œ ì „ë‹¬í•˜ëŠ”ì§€ ì „ì²´ì ì¸ êµ¬ì¡°ë¥¼ ì¢€ ë” ì‚´í´ë´ì•¼ê² ë‹¤ëŠ” ìƒê°ì„ í–ˆë‹¤.   
ì‚¬ì‹¤ ë¯¸ë“¤ì›¨ì–´ì˜ ë™ì‘ì´ë¼ê±°ë‚˜ íë¦„ì„ ì´ì œì•¼ ê³µë¶€í•˜ê³  ìˆë‹¤ëŠ” ìƒê°ë„ ë“¤ì—ˆë”°.
